package generator

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
)

// TODO: add keyword conversion

// deprecationComment is the standard comment added to deprecated
// messages, fields, enums, and enum values.
var deprecationComment = "// Deprecated: Do not use."

func kotlinPopulateHeaderComment(g *Generator, f *FileDescriptor) {
	g.P()
	g.P("// Code generated by ", GeneratorName, ". DO NOT EDIT.")
	if g.NoTime {
		g.P("// Timestamp generation disabled.")
	} else {
		g.P("// ", time.Now().Format("2006-01-02 Mon 15:04:05 UTC-0700"))
	}
	g.P("//")
	g.P("//     ", f.GetName())
	g.P("//")
	if f.GetOptions().GetDeprecated() {
		g.P(deprecationComment)
	}
	g.P()
	g.P()
}

func kotlinPopulateEnum(g *Generator, enum *EnumDescriptor) {
	if enum.parent == nil {
		g.P("package ", enumPackagePath(g, enum))
		kotlinPopulateHeaderComment(g, enum.File())
	}

	if enum.GetOptions().GetDeprecated() {
		g.P(deprecationComment)
	}

	g.PrintComments(enum.path)
	g.P("enum class ", enum.GetName(), "(var code: Int) {")

	// in order to add default value, need to iterate two rounds
	addDefaultValue := true
	defaultName := "Unknown"
	var defaultValue int32
	defaultValue = -1
	for _, e := range enum.Value {
		low := strings.ToLower(e.GetName())
		if addDefaultValue && // save some string comparison
			(strings.Contains(low, "default") ||
				strings.Contains(low, "unknow") || // the missing 'n' is for poor spelling
				strings.Contains(low, "invalid")) {
			addDefaultValue = false
			defaultName = e.GetName()
			break
		}
		if e.GetNumber() <= defaultValue {
			defaultValue = e.GetNumber() - 1
		}
	}

	g.In()

	if addDefaultValue {
		g.P(defaultName, "(", &defaultValue, "),")
	}
	for i, e := range enum.Value {
		etorPath := fmt.Sprintf("%s,%d,%d", enum.path, enumValuePath, i)
		g.PrintComments(etorPath)

		tails, ok := g.tailingComments(etorPath)
		if !ok {
			tails = ""
		} else {
			tails = fmt.Sprintf(" %s", tails)
		}

		if i == len(enum.Value)-1 {
			g.P(e.GetName(), "(", e.Number, ");", tails)
		} else {
			g.P(e.GetName(), "(", e.Number, "),", tails)
		}
	}
	g.Newline()
	g.P("companion object {")
	g.In()
	g.P("fun forNumber(value: Int): ", enum.GetName(), " {")
	g.In()
	g.P("return when (value) {")
	g.In()
	for _, e := range enum.Value {
		g.P(e.GetName(), ".code -> ", e.GetName())
	}
	g.P("else -> ", defaultName)
	g.Out()
	g.P("}")
	g.Out()
	g.P("}")
	g.Out()
	g.P("}")

	g.Out()
	g.P("}")
}

func getFieldTypeName(g *Generator, field *descriptor.FieldDescriptorProto) string {
	obj, ok := g.typeNameToObject[field.GetTypeName()]
	if !ok {
		g.Fail("unable to find object with type named,", field.GetTypeName())
	}
	// .package.name.TypeName -> package.name.TypeName
	typeName := field.GetTypeName()[1:]
	// package.name.TypeName -> TypeName
	typeName = strings.TrimPrefix(typeName, obj.File().GetPackage())[1:]

	return typeName
}

func kotlinExtractImports(g *Generator, msg *Descriptor, sysImp, usrImp map[string]string) {
	// nested descriptor's fields
	for _, nested := range msg.nested {
		kotlinExtractImports(g, nested, sysImp, usrImp)
	}

	for _, field := range msg.Field {
		switch field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_ENUM:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
			obj, ok := g.typeNameToObject[field.GetTypeName()]
			if !ok {
				g.Fail("unable to find object with type named,", field.GetTypeName())
			}
			// .package.name.TypeName -> package.name.TypeName
			typeName := field.GetTypeName()[1:]
			// package.name.TypeName -> TypeName
			typeName = strings.TrimPrefix(typeName, obj.File().GetPackage())[1:]

			// RootMsg.NestMsg -> RootMsg
			importPkg := typeName
			if strings.Contains(typeName, ".") {
				importPkg = strings.Split(typeName, ".")[0]
			}

			fullJavaImportPath := fmt.Sprintf("%s.%s", obj.JavaImportPath().String(), importPkg)
			usrImp[fullJavaImportPath] = typeName
		}
	}
}

func kotlinPopulateField(g *Generator, msg *Descriptor, field *descriptor.FieldDescriptorProto, index int) {
	typeName := ""
	typeDefaultValue := ""

	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		desc := g.ObjectNamed(field.GetTypeName())
		if d, ok := desc.(*Descriptor); ok && d.GetOptions().GetMapEntry() {
			// Figure out the kotlin types and tags for the key and value type
			keyField, valField := d.Field[0], d.Field[1]
			typeName, typeDefaultValue = kotlinPopulateMap(g, keyField, valField)
		} else {
			typeName = getFieldTypeName(g, field)
			if isRepeated(field) {
				typeName = fmt.Sprintf("List<%s>", typeName)
				typeDefaultValue = "emptyList()"
			} else {
				typeName = fmt.Sprintf("%s?", typeName)
				typeDefaultValue = "null"
			}
		}
	default:
		typeName, typeDefaultValue = kotlinType(field)
		if typeName == "" {
			g.Fail("unknown type for", field.GetName())
		}
	}

	if field.OneofIndex != nil {
		// oneof
		if !strings.HasSuffix(typeName, "?") {
			typeName = fmt.Sprintf("%v?", typeName)
		}
		typeDefaultValue = "null"
	}

	ftorPath := fmt.Sprintf("%s,%d,%d", msg.path, messageFieldPath, index)
	if c, ok := g.makeComments(ftorPath); ok {
		g.Newline()
		g.P(c)
	}
	//g.PrintComments(ftorPath)
	tail, ok := g.tailingComments(ftorPath)
	if !ok {
		tail = ""
	} else {
		tail = fmt.Sprintf(" %s", tail)
	}
	g.P("var ", javaFieldName(field), ": ", typeName, " = ", typeDefaultValue, tail)
}

func kotlinPopulateMap(g *Generator, keyField, valField *descriptor.FieldDescriptorProto) (typeName, typeDefaultValue string) {
	var keyTypeName string
	switch keyField.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		keyTypeName = getFieldTypeName(g, keyField)
	default:
		keyTypeName, _ = kotlinType(keyField)
	}

	var valTypeName string
	switch valField.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		valTypeName = getFieldTypeName(g, valField)
	default:
		valTypeName, _ = kotlinType(valField)
	}

	typeName = fmt.Sprintf("Map<%s, %s>", keyTypeName, valTypeName)
	typeDefaultValue = "mapOf()"

	return
}

func kotlinPopulateToString(g *Generator, msg *Descriptor) {
	g.P("override fun toString(): String {")
	g.In()
	g.P("return \"", msg.GetName(), "{\" +")
	g.In()
	g.In()

	sb := &strings.Builder{}

	for i, field := range msg.Field {
		name := javaFieldName(field)
		repeat := isRepeated(field)

		sb.Reset()
		sb.WriteByte('"')
		if i != 0 {
			sb.WriteString(", ")
		}

		sb.WriteString(name)

		sb.WriteByte('=')
		if field.GetType() == descriptor.FieldDescriptorProto_TYPE_STRING && !repeat {
			sb.WriteByte('\'')
		}

		sb.WriteString("\" + ")

		switch field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_BYTES:
			sb.WriteString(fmt.Sprintf("%s.size + \" bytes\"", name))
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			sb.WriteString(name)
			if !repeat {
				sb.WriteString(" + '\\''")
			}
		case descriptor.FieldDescriptorProto_TYPE_ENUM:
			sb.WriteString(name)
		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
			sb.WriteString(name)
		default:
			if repeat {
				sb.WriteString(fmt.Sprintf("%s.contentToString()", name))
			} else {
				sb.WriteString(name)
			}
		}

		sb.WriteString(" +")

		g.P(sb.String())
	}
	g.P("\"}\"")
	g.Out()
	g.Out()
	g.Out()
	g.P("}")
}

func underSamePackage(importTypeFullpath, myPackage string) bool {
	importComponents := strings.Split(importTypeFullpath, ".")
	if len(importComponents) > 1 {
		importComponents = importComponents[:len(importComponents)-1]
	}
	importPackage := strings.Join(importComponents, ".")
	return strings.Compare(importPackage, myPackage) == 0
}

func kotlinPopulateDescriptor(g *Generator, msg *Descriptor) {
	// only root messages have package announcement, header and imports
	if msg.parent == nil {
		// only root messages have these fancy stuff
		thisPackage := descriptorPackagePath(g, msg)
		g.P("package ", thisPackage)
		kotlinPopulateHeaderComment(g, msg.File())

		// imports
		sysImp := make(map[string]string)
		usrImp := make(map[string]string)
		kotlinExtractImports(g, msg, sysImp, usrImp)

		if len(usrImp) > 0 {
			usrImpKeys := make([]string, 0, len(usrImp))
			for importPath := range usrImp {
				usrImpKeys = append(usrImpKeys, importPath)
			}
			sort.Strings(usrImpKeys)
			addParagraph := false
			for _, p := range usrImpKeys {
				if !underSamePackage(p, thisPackage) {
					g.P("import ", p)
					addParagraph = true
				}
			}
			if addParagraph {
				g.P()
			}
		}

		if len(sysImp) > 0 {
			sysImpKeys := make([]string, 0, len(sysImp))
			for importPath := range sysImp {
				sysImpKeys = append(sysImpKeys, importPath)
			}
			sort.Strings(sysImpKeys)
			for _, p := range sysImpKeys {
				g.P("import ", p)
			}
			g.P()
		}
	}

	if msg.GetOptions().GetDeprecated() {
		g.P(deprecationComment)
	}

	g.PrintComments(msg.path)
	g.P("class ", msg.GetName(), " {")
	g.In()

	// fields
	oFields := make(map[int32]*oneofField)

	for i, field := range msg.Field {
		oneof := field.OneofIndex != nil
		if oneof && oFields[*field.OneofIndex] == nil {
			odp := msg.OneofDecl[int(*field.OneofIndex)]

			of := oneofField{
				name:      CamelCase(odp.GetName()),
				field:     field,
				subFields: nil,
			}

			oFields[*field.OneofIndex] = &of
		}

		if oneof {
			sf := oneofSubField{
				index: i,
				field: field,
			}

			of := oFields[*field.OneofIndex]
			if of != nil {
				of.subFields = append(of.subFields, &sf)
			}
		}

		kotlinPopulateField(g, msg, field, i)
	}
	g.Out()

	// oneof
	for _, of := range oFields {
		g.P()
		g.In()

		of.populate(g, msg)

		g.Out()
	}

	// nested enums
	for _, nestEnum := range msg.enums {
		g.P()
		g.In()
		kotlinPopulateEnum(g, nestEnum)
		g.Out()
	}

	// nested descriptors
	for _, nestDesc := range msg.nested {
		if nestDesc.GetOptions().GetMapEntry() {
			// Don't generate virtual messages for maps.
			continue
		}
		g.P()
		g.In()
		kotlinPopulateDescriptor(g, nestDesc)
		g.Out()
	}

	if len(msg.Field) > 0 {
		g.P()
		g.In()
		kotlinPopulateToString(g, msg)
	}

	g.Out()
	g.P("}")
}
