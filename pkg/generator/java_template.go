package generator

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
)

// TODO: add keyword conversion

func javaPopulateHeaderComment(g *Generator, f *FileDescriptor) {
	g.P()
	g.P("// Code generated by ", GeneratorName, ". DO NOT EDIT.")
	if g.NoTime {
		g.P("// Timestamp generation disabled.")
	} else {
		g.P("// ", time.Now().Format("2006-01-02 Mon 15:04:05 UTC-0700"))
	}
	g.P("//")
	g.P("//     ", f.GetName())
	g.P("//")
	if f.GetOptions().GetDeprecated() {
		g.P(deprecationComment)
	}
	g.P()
	g.P()
}

func javaPopulateEnum(g *Generator, enum *EnumDescriptor) {
	if enum.parent == nil {
		g.P("package ", enumPackagePath(g, enum), ";")
		javaPopulateHeaderComment(g, enum.File())
	}

	if enum.GetOptions().GetDeprecated() {
		g.P(deprecationComment)
	}

	g.PrintComments(enum.path)
	g.P("public enum ", enum.GetName(), " {")

	g.In()

	for i, e := range enum.Value {
		etorPath := fmt.Sprintf("%s,%d,%d", enum.path, enumValuePath, i)
		g.PrintComments(etorPath)

		tails, ok := g.tailingComments(etorPath)
		if !ok {
			tails = ""
		} else {
			tails = fmt.Sprintf(" %s", tails)
		}

		if i == len(enum.Value)-1 {
			g.P(e.GetName(), "(", e.Number, ");", tails)
		} else {
			g.P(e.GetName(), "(", e.Number, "),", tails)
		}
	}
	g.Newline()
	g.P("public int code;")
	g.Newline()
	g.P(enum.GetName(), "(int code) { ")
	g.In()
	g.P("this.code = code;")
	g.Out()
	g.P("}")
	g.Newline()
	g.P("/**")
	g.P(" * @deprecated Use {@link #forNumber(int)} instead.")
	g.P(" */")
	g.P("@java.lang.Deprecated")
	g.P("public static ", enum.GetName(), " valueOf(int value) {")
	g.In()
	g.P("return forNumber(value);")
	g.Out()
	g.P("}")
	g.Newline()
	g.P("public static ", enum.GetName(), " forNumber(int value) {")
	g.In()
	g.P("switch (value) {")
	g.In()
	for i := 0; i < len(enum.Value); i++ {
		e := enum.Value[(i+1)%len(enum.Value)]
		if i != len(enum.Value)-1 {
			g.P("case ", e.Number, ":")
			g.In()
			g.P("return ", e.GetName(), ";")
			g.Out()
		} else {
			g.P("default:")
			g.In()
			g.P("return ", e.GetName(), ";")
			g.Out()
		}
	}
	g.Out()
	g.P("}")
	g.Out()
	g.P("}")

	g.Out()
	g.P("}")
}

func javaExtractImports(g *Generator, msg *Descriptor, sysImp, usrImp map[string]string) {
	// nested descriptor's fields
	for _, nested := range msg.nested {
		javaExtractImports(g, nested, sysImp, usrImp)
	}

	extractUserImport := func(f *descriptor.FieldDescriptorProto) {
		obj, ok := g.typeNameToObject[f.GetTypeName()]
		if !ok {
			g.Fail("unable to find object with type named,", f.GetTypeName())
		}
		// .package.name.TypeName -> package.name.TypeName
		typeName := f.GetTypeName()[1:]
		// package.name.TypeName -> TypeName
		typeName = strings.TrimPrefix(typeName, obj.File().GetPackage())[1:]

		// RootMsg.NestMsg -> RootMsg
		importPkg := typeName
		if strings.Contains(typeName, ".") {
			importPkg = strings.Split(typeName, ".")[0]
		}

		fullJavaImportPath := fmt.Sprintf("%s.%s", obj.JavaImportPath().String(), importPkg)
		usrImp[fullJavaImportPath] = typeName
	}

	for _, field := range msg.Field {
		switch field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_ENUM:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
			desc := g.ObjectNamed(field.GetTypeName())
			if d, ok := desc.(*Descriptor); ok && d.GetOptions().GetMapEntry() {
				// Figure out the java types and tags for the key and value type
				valField := d.Field[1]
				extractUserImport(valField)
				sysImp["java.util.HashMap"] = field.GetName()
				sysImp["java.util.Map"] = field.GetName()
			} else if isRepeated(field) {
				sysImp["java.util.ArrayList"] = field.GetName()
				sysImp["java.util.List"] = field.GetName()
			}

			extractUserImport(field)
		default:
			if isRepeated(field) {
				sysImp["java.util.ArrayList"] = field.GetName()
				sysImp["java.util.List"] = field.GetName()
			}
		}
	}
}

func javaPopulateField(g *Generator, msg *Descriptor, field *descriptor.FieldDescriptorProto, index int) {
	typeName := ""
	typeDefaultValue := ""

	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		desc := g.ObjectNamed(field.GetTypeName())
		if d, ok := desc.(*Descriptor); ok && d.GetOptions().GetMapEntry() {
			// Figure out the java types and tags for the key and value type
			keyField, valField := d.Field[0], d.Field[1]
			typeName, typeDefaultValue = javaPopulateMap(g, keyField, valField)
		} else {
			typeName = getFieldTypeName(g, field)
			if isRepeated(field) {
				typeName = fmt.Sprintf("List<%s>", typeName)
				typeDefaultValue = "new ArrayList<>()"
			} else {
				typeName = fmt.Sprintf("%s", typeName)
				typeDefaultValue = "null"
			}
		}
	default:
		typeName, typeDefaultValue = javaType(field)
		if typeName == "" {
			g.Fail("unknown type for", field.GetName())
		}
	}

	ftorPath := fmt.Sprintf("%s,%d,%d", msg.path, messageFieldPath, index)
	if c, ok := g.makeComments(ftorPath); ok {
		g.Newline()
		g.P(c)
	}
	//g.PrintComments(ftorPath)
	tail, ok := g.tailingComments(ftorPath)
	if !ok {
		tail = ""
	} else {
		tail = fmt.Sprintf(" %s", tail)
	}
	g.P("public ", typeName, " ", javaFieldName(field), " = ", typeDefaultValue, ";", tail)
}

func javaPopulateMap(g *Generator, keyField, valField *descriptor.FieldDescriptorProto) (typeName, typeDefaultValue string) {
	var keyTypeName string
	switch keyField.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		keyTypeName = getFieldTypeName(g, keyField)
	default:
		keyTypeName, _ = javaType(keyField)
	}

	var valTypeName string
	switch valField.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		valTypeName = getFieldTypeName(g, valField)
	default:
		valTypeName, _ = javaType(valField)
	}

	typeName = fmt.Sprintf("Map<%s, %s>", keyTypeName, valTypeName)
	typeDefaultValue = "new HashMap<>()"

	return
}

func javaPopulateToString(g *Generator, msg *Descriptor) {
	g.P("@Override")
	g.P("public String toString() {")
	g.In()
	g.P("return \"", msg.GetName(), "{\" +")
	g.In()
	g.In()

	sb := &strings.Builder{}

	for i, field := range msg.Field {
		name := javaFieldName(field)
		repeat := isRepeated(field)

		sb.Reset()
		sb.WriteByte('"')
		if i != 0 {
			sb.WriteString(", ")
		}

		sb.WriteString(name)

		sb.WriteByte('=')
		if field.GetType() == descriptor.FieldDescriptorProto_TYPE_STRING && !repeat {
			sb.WriteByte('\'')
		}

		sb.WriteString("\" + ")

		switch field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_BYTES:
			if repeat {
				sb.WriteString(name)
			} else {
				sb.WriteString(fmt.Sprintf("%s.length + \" bytes\"", name))
			}
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			sb.WriteString(name)
			if !repeat {
				sb.WriteString(" + '\\''")
			}
		case descriptor.FieldDescriptorProto_TYPE_ENUM:
			sb.WriteString(name)
		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
			sb.WriteString(name)
		default:
			sb.WriteString(name)
		}

		sb.WriteString(" +")

		g.P(sb.String())
	}
	g.P("\"}\";")
	g.Out()
	g.Out()
	g.Out()
	g.P("}")
}

func javaPopulateDescriptor(g *Generator, msg *Descriptor) {
	// only root messages have package announcement, header and imports
	if msg.parent == nil {
		// only root messages have these fancy stuff
		thisPackage := descriptorPackagePath(g, msg)
		g.P("package ", thisPackage, ";")
		javaPopulateHeaderComment(g, msg.File())

		// imports
		sysImp := make(map[string]string)
		usrImp := make(map[string]string)
		javaExtractImports(g, msg, sysImp, usrImp)

		if len(usrImp) > 0 {
			usrImpKeys := make([]string, 0, len(usrImp))
			for importPath := range usrImp {
				usrImpKeys = append(usrImpKeys, importPath)
			}
			sort.Strings(usrImpKeys)
			addParagraph := false
			for _, p := range usrImpKeys {
				if !underSamePackage(p, thisPackage) {
					g.P("import ", p, ";")
					addParagraph = true
				}
			}
			if addParagraph {
				g.P()
			}
		}

		if len(sysImp) > 0 {
			sysImpKeys := make([]string, 0, len(sysImp))
			for importPath := range sysImp {
				sysImpKeys = append(sysImpKeys, importPath)
			}
			sort.Strings(sysImpKeys)
			for _, p := range sysImpKeys {
				g.P("import ", p, ";")
			}
			g.P()
		}
	}

	if msg.GetOptions().GetDeprecated() {
		g.P(deprecationComment)
	}

	g.PrintComments(msg.path)
	g.P("public class ", msg.GetName(), " {")
	g.In()

	// fields
	oFields := make(map[int32]*oneofField)

	for i, field := range msg.Field {
		oneof := field.OneofIndex != nil
		if oneof && oFields[*field.OneofIndex] == nil {
			odp := msg.OneofDecl[int(*field.OneofIndex)]

			of := oneofField{
				name:      CamelCase(odp.GetName()),
				field:     field,
				subFields: nil,
			}

			oFields[*field.OneofIndex] = &of
		}

		if oneof {
			sf := oneofSubField{
				index: i,
				field: field,
			}

			of := oFields[*field.OneofIndex]
			if of != nil {
				of.subFields = append(of.subFields, &sf)
			}
		}

		javaPopulateField(g, msg, field, i)
	}
	g.Out()

	// oneof
	for _, of := range oFields {
		g.P()
		g.In()

		of.populate(g, msg)

		g.Out()
	}

	// nested enums
	for _, nestEnum := range msg.enums {
		g.P()
		g.In()
		javaPopulateEnum(g, nestEnum)
		g.Out()
	}

	// nested descriptors
	for _, nestDesc := range msg.nested {
		if nestDesc.GetOptions().GetMapEntry() {
			// Don't generate virtual messages for maps.
			continue
		}
		g.P()
		g.In()
		javaPopulateDescriptor(g, nestDesc)
		g.Out()
	}

	if len(msg.Field) > 0 {
		g.P()
		g.In()
		javaPopulateToString(g, msg)
	}

	g.Out()
	g.P("}")
}
